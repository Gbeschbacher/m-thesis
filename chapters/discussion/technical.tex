The web application consists of two main parts: the first one is the data acquisition and preparation and the second one is the transition manager handling the animation. The first subsection will discuss the restrictions, advantages and disadvantages coming along with the implementation. This discussion is followed by pointing out the strengths and weaknesses of using the transition manager. The discussion is concluded with an analysis of the used technology.

\subsubsection{Data Acquisition and Data Preparation}
Automatic data acquisition and preparation with GNU-Make is very powerful and flexible. The primal strength of it is that writing a \textit{Makefile} creates a machine-readable documentation for the whole workflow. Recording each step in the process enables reproducibility later on.
Thinking of GNU-Make as a dependency graph is key. Unlike a linear and sequential script, a dependency graph is more modular. For example, a \textit{Makefile} is augmentable with deriving multiple data files from the same zip archive without repeating the download of the archive. Thus, using GNU-Make fulfills already two requirements: it scales very well if using multiple data files from different data sources is desired and modularity is provided with the ability of defining tasks for different concerns. However, one major weakness of GNU-Make is its syntax and possible complexity. Putting the facts into comparison, the advantages outweigh the disadvantages.

The primary setup of pre-calculating every needed information has one major advantage as well as one disadvantage. The client-side web application needs to deliver the file to the client with all information only once. Afterwards, everything can be used without dynamically calculating values. On the one side, the initial loading time of the application is significantly higher compared to only delivering the boundary informations. On the other hand, the acquisition and calculation of data later yields to performance drops whenever the data is needed.
A significant drawback using this setup is that showing additional information to an aggregated symbol is not possible. A thematic map based on aggregation fully relys on the preprocessed dataset. Therefore, showing additional information on the dot-map would make use of the Superstore-Sale dataset with all information accessible, whereas showing additional information for symbols or units in aggregated thematic maps depends on the preprocessed boundary file. From an abstract point of view, the practical implementation uses two different source files for showing one phenomenon, yielding to inconsistency when allowing interaction with the visualisation. Changing the visual appearance also changes their base-data and therefore consistency in interaction concepts is not possible and therefore left out.

\subsubsection{Transition Manager}
The implemented transition manager is a key part of the practical application. It specifies some kind of structure to all visualisation classes. Each step of a transition needs to be implemented in the actual class and the manager only calls the exposed functions in the correct order to create the animated transition. This concept ensures separation of concerns of each exposed function and therefore guaranteeing modularity in creating animated transitions.

The transition table \ref{tab:transition-table} on page \pageref{tab:transition-table} mentions shape transitions which are not yet implemented. This is due to the GeoJSON file acquired from the census bureau. Every enumeration unit is specified as a multipolygon. The GeoJSON specification defines multipolygons as a collection of polygons and polygons as an array of coordinates. However, a polygon can contain multiple rings. If this is the case, the first ring must be the exterior one and any others must be interior rings or holes.
Animating the morphing of an enumeration unit to a symbol would require the starting point to be a polygon in order to create a smooth transition. However, merging the multipolygon of an enumeration unit to a single polygon containing only a single outer ring is not possible. A point in the multipolygon and therefore in the map is unique. This makes it impossible to find the outer ring of multiple polygons.
Another possibility in animated morphing would be to morph each polygon to a particular segment of the symbol. With the current data, the transition will not look smooth. Some polygons in enumeration units are hidden behind the default symbol, therefore an animated morphing of those would look like a random symbol segment appearing without noticing the origin of the polygon.


\subsubsection{Used Technology}
Using ECMAScript6 was not the best choice. Decker presents ECMAScript6 polyfill performance tests. He implements a specific feature with multiple JavaScript versions and compairs their runtime. Furthermore, he uses multiple different transpilers yielding considerable results. The following discussion only includes features which are used in the practical application. It also focuses on the results for Chrome 51, because this is the browser version used for testing the application \iacite{Decker2016}.

His report\footnote{See \href{https://kpdecker.github.io/six-speed/}{https://kpdecker.github.io/six-speed/} for more information.} shows that using classes in combination with babel as a transpiler is $1,8\times$ slower in chrome 51 compared to the default way of creating an object in JavaScript. In addition, using default parameters and calling a parent class with the super keyword is significantly slower. However, the usage of promises is a little bit faster in Chrome 51 \iacite{Decker2016}.

Nonetheless, comparing the used version of JavaScript with its performance with its readability, it is still reasonable because of the better maintainability of the code. Despite its advantage, it is still needed to consider using a different transpiler or JavaScript version if the application should use larger datasets or lacks performance.

\ac{D3} is a proper library providing a huge set of useful functions. Its flexibility and functional style allows code reuse. The usage of this library in the practical application shows no drawbacks at all. Animating all symbols at once or with different timings and applying forces such as gravity is neither a performance problem, nor an implementation problem. However, using \ac{DOM} elements always depends on a proper use of JavaScript. For example, considering a memory leak because of keeping references to deleted \ac{DOM} elements would result in an unresponsive browser.

\ac{Pixi} does not show any disadvantage in the currently implemented application. Displaying particles as sprites is a very scaleable way and animating them with a generalised render function combined with an animation queue provides modularity.